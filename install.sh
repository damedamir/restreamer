#!/bin/bash

# Restreamer Automated Installation Script
# This script configures the application for any domain

set -e

echo "🚀 Restreamer Installation Script"
echo "================================="
echo ""

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print colored output
print_status() {
    echo -e "${GREEN}✅ $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}⚠️  $1${NC}"
}

print_error() {
    echo -e "${RED}❌ $1${NC}"
}

print_info() {
    echo -e "${BLUE}ℹ️  $1${NC}"
}

# Check if running as root
if [[ $EUID -eq 0 ]]; then
   print_error "This script should not be run as root for security reasons"
   exit 1
fi

# Check if Docker is installed
if ! command -v docker &> /dev/null; then
    print_error "Docker is not installed. Please install Docker first."
    exit 1
fi

# Check if Docker Compose is installed
if ! command -v docker-compose &> /dev/null && ! docker compose version &> /dev/null; then
    print_error "Docker Compose is not installed. Please install Docker Compose first."
    exit 1
fi

print_status "Docker and Docker Compose are installed"

# Detect existing Traefik setup
print_info "Detecting existing Traefik configuration..."
TRAEFIK_DETECTED=false
WEB_PROXY_NETWORK_EXISTS=false

# Check if web-proxy network exists
if docker network ls | grep -q "web-proxy"; then
    WEB_PROXY_NETWORK_EXISTS=true
    print_status "Found existing web-proxy network"
fi

# Check if Traefik container is running
if docker ps | grep -q "traefik"; then
    TRAEFIK_DETECTED=true
    print_status "Found running Traefik container"
fi

# Check if Traefik compose file exists
if [ -f "docker-compose.traefik.yml" ] || [ -f "traefik.yml" ] || [ -f "traefik/docker-compose.yml" ]; then
    TRAEFIK_DETECTED=true
    print_status "Found Traefik configuration files"
fi

echo ""
echo "📋 Configuration Setup"
echo "======================"
echo ""

# Get domain input
while true; do
    read -p "Enter your domain (e.g., restreamer.example.com): " DOMAIN
    if [[ -n "$DOMAIN" ]]; then
        break
    else
        print_error "Domain cannot be empty. Please enter a valid domain."
    fi
done

# Get protocol preference
echo ""
echo "Protocol options:"
echo "1) HTTPS (recommended for production)"
echo "2) HTTP (for development/testing)"
read -p "Choose protocol [1-2]: " PROTOCOL_CHOICE

case $PROTOCOL_CHOICE in
    1)
        PROTOCOL="https"
        ;;
    2)
        PROTOCOL="http"
        ;;
    *)
        PROTOCOL="https"
        print_warning "Invalid choice, defaulting to HTTPS"
        ;;
esac

# Traefik configuration
echo ""
echo "Traefik Configuration:"
if [ "$TRAEFIK_DETECTED" = true ]; then
    echo "✅ Traefik detected on this server"
    if [ "$WEB_PROXY_NETWORK_EXISTS" = true ]; then
        echo "✅ web-proxy network found"
        USE_TRAEFIK=true
    else
        echo "⚠️  Traefik detected but web-proxy network missing"
        echo "1) Create web-proxy network and use Traefik"
        echo "2) Use direct port mapping (no Traefik)"
        read -p "Choose option [1-2]: " TRAEFIK_CHOICE
        case $TRAEFIK_CHOICE in
            1)
                USE_TRAEFIK=true
                ;;
            2)
                USE_TRAEFIK=false
                ;;
            *)
                USE_TRAEFIK=true
                print_warning "Invalid choice, defaulting to Traefik"
                ;;
        esac
    fi
else
    echo "❌ No Traefik detected"
    echo "1) Install and configure Traefik"
    echo "2) Use direct port mapping (no Traefik)"
    read -p "Choose option [1-2]: " TRAEFIK_CHOICE
    case $TRAEFIK_CHOICE in
        1)
            USE_TRAEFIK=true
            INSTALL_TRAEFIK=true
            ;;
        2)
            USE_TRAEFIK=false
            INSTALL_TRAEFIK=false
            ;;
        *)
            USE_TRAEFIK=false
            INSTALL_TRAEFIK=false
            print_warning "Invalid choice, defaulting to direct port mapping"
            ;;
    esac
fi

# Generate JWT secret
JWT_SECRET=$(openssl rand -hex 32)

# Generate database password
DB_PASSWORD=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-25)

print_info "Configuration Summary:"
echo "  Domain: $DOMAIN"
echo "  Protocol: $PROTOCOL"
echo "  Traefik: $([ "$USE_TRAEFIK" = true ] && echo "Yes" || echo "No")"
if [ "$USE_TRAEFIK" = true ] && [ "$INSTALL_TRAEFIK" = true ]; then
    echo "  Install Traefik: Yes"
fi
echo "  JWT Secret: Generated"
echo "  DB Password: Generated"
echo ""

read -p "Continue with installation? [y/N]: " CONFIRM
if [[ ! $CONFIRM =~ ^[Yy]$ ]]; then
    print_warning "Installation cancelled"
    exit 0
fi

echo ""
echo "🔧 Generating Configuration Files"
echo "================================="

# Create .env file
print_info "Creating .env file..."
cat > .env << EOF
# Generated by install.sh on $(date)

# Database
DATABASE_URL="postgresql://restreamer_user:${DB_PASSWORD}@restreamer-postgres:5432/restreamer_db"

# JWT Secret
JWT_SECRET="${JWT_SECRET}"

# API Configuration
API_PORT=3001
FRONTEND_PORT=3000

# Domain Configuration
DOMAIN="${DOMAIN}"
API_URL="${PROTOCOL}://api.${DOMAIN}"
FRONTEND_URL="${PROTOCOL}://${DOMAIN}"

# SRS Configuration
SRS_RTMP_URL="rtmp://${DOMAIN}:1935/live"
SRS_API_URL="http://restreamer-srs:1985/api"
SRS_WEBRTC_URL="http://restreamer-srs:8000/rtc"

# Security
CORS_ORIGIN="${PROTOCOL}://${DOMAIN}"
ALLOWED_ORIGINS="${PROTOCOL}://${DOMAIN},${PROTOCOL}://api.${DOMAIN}"

# Logging
LOG_LEVEL="info"
NODE_ENV="production"
EOF

print_status ".env file created"

# Create production docker-compose.yml
print_info "Creating production docker-compose.yml..."
if [ "$USE_TRAEFIK" = true ]; then
    # Use Traefik configuration
    cat > docker-compose.production.yml << EOF
version: '3.8'

services:
  postgres:
    image: postgres:16-alpine
    container_name: restreamer-postgres
    environment:
      POSTGRES_DB: restreamer_db
      POSTGRES_USER: restreamer_user
      POSTGRES_PASSWORD: ${DB_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - restreamer-network
    restart: always
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U restreamer_user -d restreamer_db"]
      interval: 10s
      timeout: 5s
      retries: 5

  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile.final
    container_name: restreamer-backend
    environment:
      DATABASE_URL: "postgresql://restreamer_user:${DB_PASSWORD}@restreamer-postgres:5432/restreamer_db"
      JWT_SECRET: "${JWT_SECRET}"
      NODE_ENV: "production"
    depends_on:
      postgres:
        condition: service_healthy
    networks:
      - restreamer-network
      - web-proxy
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.restreamer-backend.rule=Host(\`${DOMAIN}\`) && (PathPrefix(\`/api\`) || PathPrefix(\`/health\`))"
      - "traefik.http.routers.restreamer-backend.entrypoints=web"
      - "traefik.http.services.restreamer-backend.loadbalancer.server.port=3001"
    restart: always

  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile.simple
    container_name: restreamer-frontend
    environment:
      NEXT_PUBLIC_BASE_URL: ${PROTOCOL}://${DOMAIN}
    networks:
      - restreamer-network
      - web-proxy
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.restreamer-frontend.rule=Host(\`${DOMAIN}\`)"
      - "traefik.http.routers.restreamer-frontend.entrypoints=web"
      - "traefik.http.services.restreamer-frontend.loadbalancer.server.port=3000"
    restart: always

  srs:
    image: ossrs/srs:6
    container_name: restreamer-srs
    ports:
      - "1935:1935"
      - "8082:8080"
      - "10080:10080/udp"
      - "8000:8000/udp"
      - "9000:9000"
      - "5060:5060"
    volumes:
      - ./srs-v6-flv-correct.conf:/usr/local/srs/conf/srs.conf
    command: ["./objs/srs", "-c", "conf/srs.conf"]
    networks:
      - restreamer-network
    restart: always

volumes:
  postgres_data:

networks:
  restreamer-network:
    driver: bridge
  web-proxy:
    external: true
EOF
else
    # Use direct port mapping configuration
    cat > docker-compose.production.yml << EOF
version: '3.8'

services:
  postgres:
    image: postgres:16-alpine
    container_name: restreamer-postgres
    environment:
      POSTGRES_DB: restreamer_db
      POSTGRES_USER: restreamer_user
      POSTGRES_PASSWORD: ${DB_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - restreamer-network
    restart: always
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U restreamer_user -d restreamer_db"]
      interval: 10s
      timeout: 5s
      retries: 5

  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile.final
    container_name: restreamer-backend
    environment:
      DATABASE_URL: "postgresql://restreamer_user:${DB_PASSWORD}@restreamer-postgres:5432/restreamer_db"
      JWT_SECRET: "${JWT_SECRET}"
      NODE_ENV: "production"
    depends_on:
      postgres:
        condition: service_healthy
    networks:
      - restreamer-network
    ports:
      - "3001:3001"
    restart: always

  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile.simple
    container_name: restreamer-frontend
    environment:
      NEXT_PUBLIC_BASE_URL: ${PROTOCOL}://${DOMAIN}
    networks:
      - restreamer-network
    ports:
      - "3000:3000"
    restart: always

  srs:
    image: ossrs/srs:6
    container_name: restreamer-srs
    ports:
      - "1935:1935"
      - "8082:8080"
      - "10080:10080/udp"
      - "8000:8000/udp"
      - "9000:9000"
      - "5060:5060"
    volumes:
      - ./srs-v6-flv-correct.conf:/usr/local/srs/conf/srs.conf
    command: ["./objs/srs", "-c", "conf/srs.conf"]
    networks:
      - restreamer-network
    restart: always

volumes:
  postgres_data:

networks:
  restreamer-network:
    driver: bridge
EOF
fi

print_status "Production docker-compose.yml created"


# Create deployment script
print_info "Creating deployment script..."
cat > deploy.sh << EOF
#!/bin/bash

# Restreamer Deployment Script
# Generated by install.sh

echo "🚀 Starting Restreamer deployment..."

# Check if .env exists
if [ ! -f .env ]; then
    echo "❌ .env file not found. Please run install.sh first."
    exit 1
fi

# Load environment variables
source .env

echo "📥 Pulling latest changes from GitHub..."
git pull origin main

echo "🛑 Stopping all containers..."
docker compose -f docker-compose.production.yml down || true

echo "🧹 Cleaning up old containers and volumes..."
docker system prune -f
docker volume prune -f

echo "🔨 Rebuilding and starting all services..."
docker compose -f docker-compose.production.yml up -d --build

echo "⏳ Waiting for services to start..."
sleep 30

echo "📊 Checking service status..."
docker compose -f docker-compose.production.yml ps

echo "✅ Deployment complete!"
echo "🌐 Website: ${PROTOCOL}://${DOMAIN}"
echo "📊 Admin: ${PROTOCOL}://${DOMAIN}/admin"
echo "🔌 API: ${PROTOCOL}://${DOMAIN}/api"
EOF

chmod +x deploy.sh
print_status "Deployment script created"

# Create setup script for default data
print_info "Creating setup script..."
cat > setup-default-config.sh << EOF
#!/bin/bash

# Setup default configuration
# Generated by install.sh

echo "🔧 Setting up default configuration..."

# Wait for backend to be ready
echo "⏳ Waiting for backend to be ready..."
sleep 10

# Create database schema first
echo "🗄️  Creating database schema..."
docker exec restreamer-backend npx prisma db push

# Wait a moment for schema to be created
sleep 5

# Create default admin user
echo "👤 Creating default admin user..."
docker exec restreamer-backend node -e "
const { PrismaClient } = require('@prisma/client');
const bcrypt = require('bcryptjs');

async function createAdmin() {
  const prisma = new PrismaClient();
  
  try {
    const hashedPassword = await bcrypt.hash('admin123', 12);
    
    await prisma.user.upsert({
      where: { email: 'admin@${DOMAIN}' },
      update: {},
      create: {
        id: 'admin-1',
        email: 'admin@${DOMAIN}',
        password: hashedPassword,
        name: 'Admin User',
        role: 'ADMIN'
      }
    });
    
    console.log('✅ Admin user created: admin@${DOMAIN}');
    console.log('🔑 Password: admin123');
  } catch (error) {
    console.error('❌ Error creating admin user:', error);
  } finally {
    await prisma.\$disconnect();
  }
}

createAdmin();
"

echo "✅ Setup complete!"
EOF

chmod +x setup-default-config.sh
print_status "Setup script created"

# Install Traefik if requested
if [ "$USE_TRAEFIK" = true ] && [ "$INSTALL_TRAEFIK" = true ]; then
    echo ""
    echo "🔧 Installing Traefik"
    echo "===================="
    
    # Create web-proxy network
    if [ "$WEB_PROXY_NETWORK_EXISTS" = false ]; then
        print_info "Creating web-proxy network..."
        docker network create web-proxy
        print_status "web-proxy network created"
    fi
    
    # Create Traefik configuration
    print_info "Creating Traefik configuration..."
    cat > docker-compose.traefik.yml << EOF
version: '3.8'

services:
  traefik:
    image: traefik:v3.0
    container_name: traefik
    command:
      - --api.dashboard=true
      - --api.insecure=true
      - --providers.docker=true
      - --providers.docker.exposedbydefault=false
      - --entrypoints.web.address=:80
      - --entrypoints.websecure.address=:443
      - --log.level=INFO
    ports:
      - "80:80"
      - "443:443"
      - "8081:8080"  # Traefik dashboard
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
    networks:
      - web-proxy
    restart: unless-stopped

networks:
  web-proxy:
    external: true
EOF
    
    # Start Traefik
    print_info "Starting Traefik..."
    docker compose -f docker-compose.traefik.yml up -d
    print_status "Traefik started"
    
    # Wait for Traefik to be ready
    print_info "Waiting for Traefik to be ready..."
    sleep 10
fi

# Create web-proxy network if using Traefik but network doesn't exist
if [ "$USE_TRAEFIK" = true ] && [ "$WEB_PROXY_NETWORK_EXISTS" = false ]; then
    print_info "Creating web-proxy network..."
    docker network create web-proxy
    print_status "web-proxy network created"
fi

echo ""
echo "🎉 Installation Complete!"
echo "========================="
echo ""
print_status "Configuration files generated:"
echo "  📄 .env - Environment variables"
echo "  📄 docker-compose.production.yml - Production configuration"
echo "  📄 docker-compose.server.yml - Server configuration"
echo "  📄 deploy.sh - Deployment script"
echo "  📄 setup-default-config.sh - Setup script"
echo ""
print_info "Next steps:"
echo "1. Review the generated .env file"
echo "2. Run: ./deploy.sh"
echo "3. Run: ./setup-default-config.sh"
echo ""
print_warning "Important: Make sure your domain points to this server's IP address"
echo ""
print_info "Default admin credentials:"
echo "  Email: admin@${DOMAIN}"
echo "  Password: admin123"
echo ""
print_status "Installation completed successfully!"
